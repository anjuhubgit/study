Best practices and troubleshooting 

This final set of best practices will ensure Alice's team runs their Git repository like a well-oiled machine, handling edge cases and maintaining professional standards.

üîí The Craft of Code Management: Best Practices and Troubleshooting
Alice and her team have the tools, but now they need the discipline to use them effectively and the knowledge to fix problems when they arise.

1. Commit Message Conventions: The Historian's Rule
As the team grew, so did the number of commits. Alice quickly found that vague messages like "fixed bug" or "some changes" made it impossible to trace the history of a recipe.

The Rule: Alice implemented a strict commit message convention‚Äîthe "Historian's Rule."

Subject Line (The Summary): Must be concise and informative (50 characters or less), summarizing the change type and scope. (e.g., feat(Sourdough): Add starter hydration logic).

Body (The Details): Must be separated by a blank line and explain the why of the change, not just the what. (e.g., ‚ÄúThis commit implements hydration calculations based on user input to fix reported dough stickiness. The previous hardcoded value led to inconsistent results.‚Äù)

The Benefit: When a feature breaks, Alice can use git log to instantly understand why a change was made and who made it, speeding up debugging dramatically.

2. Handling Large Files: The Separate Warehouse
The digital bakery contained large video assets of cakes, high-resolution product photos, and design mockups. When these files were committed directly to Git, the repository size ballooned, making cloning and pulling painfully slow for everyone.

The Problem: Git is designed for tracking changes in text files (code), not storing large binary files.

The Solution: Git Large File Storage (Git LFS)

Concept: Git LFS is like creating a separate warehouse for large binary files. When Alice commits a large file (e.g., a 50MB cake video), Git LFS replaces the actual file in the repository with a tiny pointer file (a simple text reference).

Action: The actual large file is uploaded to the Git LFS server (the warehouse). Only when a developer checks out that file does Git LFS download the full file from the warehouse.

The Benefit: The repository stays small and fast, while developers still have access to the necessary large assets.

3. Security: Locking Up the Credentials
Alice learned the hard way that a single leak could ruin the entire operation. Her database passwords and cloud API keys were accidentally committed into the public repository by a rushed developer.

The Practice: Never commit secrets to Git, ever.

The Solution (Secrets Management):

Environment Variables: Store passwords and keys in environment variables on the server. The application reads these secrets at runtime, and they are never written to any file in the repository.

.gitignore: Alice created a robust .gitignore file to automatically block common secret files (like .env files or temporary configuration files) from ever being tracked by Git.

CI/CD Secrets: Use dedicated secret management features of the CI/CD platform (like Kubernetes Secrets or GitLab CI/CD Secrets) to securely inject credentials only when and where they are needed for deployment.

4. Troubleshooting Common Git Issues: The Fix-It Manual
Even with best practices, developers occasionally run into confusing Git states.

A. The Detached HEAD
The Problem: A developer checks out an old commit ID or a tag instead of a branch name. Git says they are in a "detached HEAD" state. It‚Äôs like being in a Git time machine, but if they make new commits, those commits aren't attached to any branch and can easily be lost when they switch back to a branch.

The Fix: Alice advises: "You are looking at history, not working on a branch." If they want to develop from that point, they must create a new branch immediately: git checkout -b new-bug-fix-branch.

B. Untracked Files
The Problem: The developer runs git status and sees files listed under "Untracked files." This usually means temporary files, compiled code, or log files are cluttering the workspace.

The Fix: If the file should be ignored (like log files), add its pattern to the .gitignore file and commit the .gitignore change. If the file should be tracked, use git add [filename].

C. Conflicting Files on Pull
The Problem: Alice makes a change to the "cookie recipe," and Ben makes a different change to the same line of the same file. When Alice tries to git pull, Git stops and reports a merge conflict.

The Fix: Git marks the conflicting areas in the file with <<<<<<< HEAD, =======, and >>>>>>> remote-branch. Alice must manually edit the file, choose which version of the change to keep (or combine them), remove all the Git conflict markers, save the file, and then run git add [conflicted-file] followed by git commit to finalize the conflict resolution.

By instituting these final layers of discipline and knowledge, Alice secured her repository, maintained a clean history, and empowered her team to debug and resolve common issues, leaving them free to focus on baking the best digital cookies in the world.